<!doctype html>
<html lang="fr">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>DetourZero â€” Optimiseur de tournÃ©e (client-side)</title>

    <link rel="stylesheet" href="style.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

    <style>
        /* spinner bouton */
        .btn.loading {
            opacity: 0.6;
            pointer-events: none;
            position: relative;
        }

        .btn.loading .spinner {
            display: inline-block;
            width: 1em;
            height: 1em;
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 0.7s linear infinite;
            vertical-align: middle;
            margin-right: 6px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>
    <header>
        <div class="logo" aria-hidden="true"></div>
        <h1>DetourZero â€” Optimiseur de tournÃ©e</h1>
        <span class="tag">100% client-side Â· OSRM Â· Nominatim</span>
    </header>

    <main class="wrap">
        <!-- Colonne gauche -->
        <section class="panel">
            <div class="row">
                <label>Ajouter une adresse (dÃ©part = premiÃ¨re ligne)</label>

                <div class="grid-form">
                    <!-- Champ NOM CLIENT avec suggestions -->
                    <input id="client" placeholder="Nom client (ex: Leroy Merlin)" list="clientSuggestions" />
                    <datalist id="clientSuggestions"></datalist>

                    <!-- Champ ADRESSE avec suggestions -->
                    <input id="addr" placeholder="Adresse (ex: 5 Rue de l'Ã‰glise, 62570 Helfaut)"
                        list="addrSuggestions" />
                    <datalist id="addrSuggestions"></datalist>

                    <div class="hstack form-actions">
                        <button class="btn primary" id="add">+ Ajouter</button>
                        <button class="btn ghost" id="clear">Vider la liste</button>
                    </div>
                </div>
            </div>

            <div class="row hstack">
                <button class="btn" id="geocode">1) GÃ©ocoder</button>
                <button class="btn primary" id="optimize" disabled>2) Optimiser</button>
                <button class="btn accent" id="draw" disabled>3) Tracer lâ€™itinÃ©raire</button>
            </div>

            <div class="row">
                <label>Ã‰tapes</label>
                <div class="list" id="list">
                    <div class="empty mini">Aucun arrÃªt â€” ajoute une adresse.</div>
                </div>

                <div class="summary" style="margin-top:10px">
                    <div class="sum" id="sumDist">Distance totale : â€“</div>
                    <div class="sum" id="sumTime">DurÃ©e totale (â‰ˆ) : â€“</div>
                </div>
            </div>
        </section>

        <!-- Carte -->
        <section class="panel map-panel">
            <div id="map">
                <div class="map-placeholder">
                    <div class="map-title">AperÃ§u carte</div>
                    <div class="map-hint">(Le tracÃ© sâ€™affichera aprÃ¨s Â« Tracer lâ€™itinÃ©raire Â»)</div>
                </div>
            </div>
        </section>
    </main>

    <!-- ========== JS ========== -->
    <script>
        // ------- Raccourci sÃ©lecteur -------
        const $ = s => document.querySelector(s);

        // ------- RÃ©fÃ©rences DOM -------
        const el = {
            client: $('#client'),
            clientSuggestions: $('#clientSuggestions'),

            addr: $('#addr'),
            addrSuggestions: $('#addrSuggestions'),

            add: $('#add'),
            clear: $('#clear'),

            geocode: $('#geocode'),
            optimize: $('#optimize'),
            draw: $('#draw'),

            list: $('#list'),
            sumDist: $('#sumDist'),
            sumTime: $('#sumTime')
        };

        // ------- Persistance -------
        const LS_KEY = 'detourzero_clients_nowo_v1';
        // Chaque entrÃ©e brute : {id, name, address}
        let raw = [];
        const genId = () =>
            Math.random().toString(36).slice(2) + Date.now().toString(36);

        function saveState() {
            localStorage.setItem(LS_KEY, JSON.stringify(raw));
        }

        function loadState() {
            try {
                raw = JSON.parse(localStorage.getItem(LS_KEY) || '[]') || [];
                raw.forEach(r => {
                    if (!r.id) r.id = genId();
                });
            } catch {
                raw = [];
            }
        }

        // Points gÃ©ocodÃ©s aprÃ¨s "GÃ©ocoder"
        // {id,index,name,address,lat,lon,display}
        let points = [];
        // Chemin optimisÃ©
        let ordered = [];
        // GeoJSON du trajet
        let routeGeo = null;

        // ------- Helpers temps / format -------
        const minsToStr = m => {
            m = Math.round(m);
            const h = Math.floor(m / 60),
                mm = m % 60;
            return h
                ? `${h} h ${String(mm).padStart(2, '0')} min`
                : `${mm} min`;
        };

        // ------- Leaflet / Carte -------
        const map = L.map('map').setView([48.8566, 2.3522], 6);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '&copy; OpenStreetMap'
        }).addTo(map);

        const markersLayer = L.layerGroup().addTo(map);
        const routeLayer = L.geoJSON(null, { style: { weight: 4 } }).addTo(map);

        function fitTo(arr) {
            if (!arr.length) return;
            map.fitBounds(
                L.latLngBounds(arr.map(p => [p.lat, p.lon])),
                { padding: [28, 28] }
            );
        }

        function clearMap() {
            markersLayer.clearLayers();
            routeLayer.clearLayers();
            routeGeo = null;
        }

        function drawMarkers() {
            markersLayer.clearLayers();
            points.forEach((p, i) => {
                L.marker([p.lat, p.lon])
                    .addTo(markersLayer)
                    .bindPopup(
                        `<b>${i === 0 ? 'DÃ©pÃ´t ' : ''}#${i}</b><br>` +
                        `${p.name ? ('<i>' + p.name + '</i><br>') : ''}` +
                        `${p.display || p.address}`
                    );
            });
            if (points.length) fitTo(points);
        }

        // ------- Rendu de la liste -------
        function renderList(view = 'raw') {
            const src = (view === 'ordered' && ordered.length)
                ? ordered
                : (points.length
                    ? points
                    : raw.map((r, i) => ({
                        id: r.id,
                        index: i,
                        name: r.name,
                        address: r.address
                    }))
                );

            if (!src.length) {
                el.list.innerHTML = '<div class="empty mini">Aucun arrÃªt â€” ajoute une adresse.</div>';
                return;
            }

            el.list.innerHTML = src.map((p, i) => `
            <div class="card">
                <div class="idx">${i}</div>
                <div class="txt">
                    <div><strong>${p.name || '(Sans nom)'}</strong></div>
                    <div class="mini">${p.address || ''}</div>
                    ${p.lat && p.lon
                    ? `<div class="mini">(${p.lat.toFixed(5)}, ${p.lon.toFixed(5)})</div>`
                    : ''}
                </div>
                <button class="iconbtn" title="Supprimer" onclick="delStop('${p.id}')">ðŸ—‘</button>
            </div>
        `).join('');
        }

        // suppression d'une seule ligne
        window.delStop = function (id) {
            const i = raw.findIndex(r => r.id === id);
            if (i > -1) raw.splice(i, 1);

            saveState();

            // enlÃ¨ve aussi cÃ´tÃ© points/ordered
            points = points.filter(p => p.id !== id);
            ordered = ordered.filter(p => p.id !== id);

            clearMap();
            drawMarkers();
            renderList();

            // rÃ©initialise boutons
            el.optimize.disabled = points.length > 1 ? false : true;
            el.draw.disabled = true;

            el.sumDist.textContent = 'Distance totale : â€“';
            el.sumTime.textContent = 'DurÃ©e totale (â‰ˆ) : â€“';
        };

        // ------- Ajout client -------
        el.add.addEventListener('click', () => {
            const name = el.client.value.trim();
            const addr = el.addr.value.trim();

            if (!addr) {
                alert('Adresse obligatoire.');
                return;
            }
            if (raw.length >= 150) {
                alert('Limite : 150 adresses.');
                return;
            }

            raw.push({
                id: genId(),
                name,
                address: addr
            });
            saveState();

            // reset champs
            el.client.value = '';
            el.addr.value = '';
            el.clientSuggestions.innerHTML = '';
            el.addrSuggestions.innerHTML = '';

            renderList();
        });

        // Enter dans adresse = add
        el.addr.addEventListener('keydown', e => {
            if (e.key === 'Enter') {
                e.preventDefault();
                el.add.click();
            }
        });

        // ------- Vider toute la liste -------
        el.clear.addEventListener('click', () => {
            if (!raw.length) {
                alert('La liste est dÃ©jÃ  vide.');
                return;
            }
            if (!confirm('Vider TOUTE la liste de clients ?')) return;

            raw = [];
            saveState();

            points = [];
            ordered = [];
            clearMap();
            renderList();

            el.optimize.disabled = true;
            el.draw.disabled = true;

            el.sumDist.textContent = 'Distance totale : â€“';
            el.sumTime.textContent = 'DurÃ©e totale (â‰ˆ) : â€“';
        });

        // ============================
        // AUTOCOMPLÃ‰TION ADRESSE
        // ============================
        let addrTimer = null;
        el.addr.addEventListener('input', () => {
            const q = el.addr.value.trim();
            if (addrTimer) clearTimeout(addrTimer);

            if (q.length < 4) {
                el.addrSuggestions.innerHTML = '';
                return;
            }

            addrTimer = setTimeout(async () => {
                try {
                    let query = q;
                    if (!/france/i.test(q)) {
                        query = q + ', France';
                    }

                    const url =
                        'https://nominatim.openstreetmap.org/search' +
                        '?format=jsonv2' +
                        '&limit=5' +
                        '&accept-language=fr' +
                        '&addressdetails=0' +
                        `&q=${encodeURIComponent(query)}`;

                    const r = await fetch(url, {
                        headers: {
                            'Accept': 'application/json',
                            'User-Agent': 'DetourZero-localtest/1.0 (contact: test@example.com)'
                        }
                    });

                    if (!r.ok) {
                        console.warn('Nominatim a rÃ©pondu', r.status);
                        el.addrSuggestions.innerHTML = '';
                        return;
                    }

                    const data = await r.json();
                    if (!Array.isArray(data) || data.length === 0) {
                        el.addrSuggestions.innerHTML = '';
                        return;
                    }

                    el.addrSuggestions.innerHTML = data.map(res => {
                        const label = (res.display_name || '')
                            .replace(/"/g, '&quot;');
                        return `<option value="${label}"></option>`;
                    }).join('');

                } catch (err) {
                    console.warn('Erreur autocomplÃ©tion adresse :', err);
                    el.addrSuggestions.innerHTML = '';
                }
            }, 300);
        });

        // ============================
        // AUTOCOMPLÃ‰TION CLIENT (NOM) + REMPLISSAGE ADRESSE
        // ============================

        // On va mÃ©moriser les suggestions renvoyÃ©es pour savoir
        // quelle adresse correspond Ã  quelle ligne affichÃ©e
        let lastClientSuggestions = []; // [{label, name, fullAddress}]

        let clientTimer = null;
        el.client.addEventListener('input', () => {
            const q = el.client.value.trim();
            if (clientTimer) clearTimeout(clientTimer);

            if (q.length < 2) { // Leroy, Carrefour, etc. peut Ãªtre court
                el.clientSuggestions.innerHTML = '';
                lastClientSuggestions = [];
                return;
            }

            clientTimer = setTimeout(async () => {
                try {
                    // RequÃªte Nominatim basÃ©e sur le nom du commerce
                    // On ajoute ", France" pour cibler le pays
                    let query = q;
                    if (!/france/i.test(q)) {
                        query = q + ', France';
                    }

                    const url =
                        'https://nominatim.openstreetmap.org/search' +
                        '?format=jsonv2' +
                        '&limit=5' +
                        '&accept-language=fr' +
                        '&addressdetails=1' + // <-- on veut les infos d'adresse
                        `&q=${encodeURIComponent(query)}`;

                    const r = await fetch(url, {
                        headers: {
                            'Accept': 'application/json',
                            'User-Agent': 'DetourZero-localtest/1.0 (contact: test@example.com)'
                        }
                    });

                    if (!r.ok) {
                        console.warn('Nominatim a rÃ©pondu (client)', r.status);
                        el.clientSuggestions.innerHTML = '';
                        lastClientSuggestions = [];
                        return;
                    }

                    const data = await r.json();
                    if (!Array.isArray(data) || data.length === 0) {
                        el.clientSuggestions.innerHTML = '';
                        lastClientSuggestions = [];
                        return;
                    }

                    // On construit un label lisible :
                    // "Leroy Merlin Boulogne-sur-Mer â€” 12 Rue X, 62200 Boulogne-sur-Mer"
                    lastClientSuggestions = data.map(res => {
                        const display = res.display_name || '';
                        // On essaie d'extraire un nom court + ville
                        // Nominatim donne parfois "Leroy Merlin, Rue X, Ville, DÃ©partement, France"
                        // On va juste rÃ©utiliser display_name tel quel pour Ãªtre sÃ»r.
                        return {
                            label: display,
                            name: display.split(',')[0].trim(), // premiÃ¨re partie = "Leroy Merlin" ou "Leroy Merlin Boulogne-sur-Mer"
                            fullAddress: display
                        };
                    });

                    el.clientSuggestions.innerHTML = lastClientSuggestions.map(sug => {
                        const safe = sug.label.replace(/"/g, '&quot;');
                        return `<option value="${safe}"></option>`;
                    }).join('');

                } catch (err) {
                    console.warn('Erreur autocomplÃ©tion client :', err);
                    el.clientSuggestions.innerHTML = '';
                    lastClientSuggestions = [];
                }
            }, 300);
        });

        // Quand l'utilisateur choisit une entrÃ©e du datalist client :
        // -> on remplit client avec le nom court
        // -> on remplit addr avec l'adresse complÃ¨te
        el.client.addEventListener('change', () => {
            const chosen = el.client.value.trim();
            if (!chosen) return;

            // On cherche dans lastClientSuggestions celle qui matche le mieux
            const match = lastClientSuggestions.find(sug => sug.label === chosen);
            if (match) {
                // On met le nom plus "propre"
                el.client.value = match.name;
                // On colle l'adresse dÃ©taillÃ©e dans le champ adresse
                el.addr.value = match.fullAddress;
            }
        });

        // ------- Fonctions de chargement bouton (spinner) -------
        function startLoading(buttonEl, loadingText) {
            buttonEl.classList.add('loading');
            buttonEl.innerHTML = `<span class="spinner"></span>${loadingText}`;
            buttonEl.disabled = true;
        }
        function stopLoading(buttonEl, normalText) {
            buttonEl.classList.remove('loading');
            buttonEl.textContent = normalText;
            buttonEl.disabled = false;
        }

        // ------- GÃ©ocodage (convertir toutes les adresses en lat/lon) -------
        async function geocodeAll(items) {
            const out = [];

            for (const it of items) {
                const s = (it.address || '').trim();
                if (!s) continue;

                // DÃ©jÃ  des coordonnÃ©es "lat,lon" ?
                const m = s.match(/(-?\d+\.?\d*)[,; ]+(-?\d+\.?\d*)/);
                if (
                    m &&
                    Math.abs(+m[1]) <= 90 &&
                    Math.abs(+m[2]) <= 180
                ) {
                    out.push({
                        id: it.id,
                        index: out.length,
                        name: it.name || '',
                        address: it.address,
                        lat: +m[1],
                        lon: +m[2],
                        display: it.address
                    });
                    continue;
                }

                // Nominatim
                let query = s;
                if (!/france/i.test(query)) {
                    query = query + ', France';
                }

                const url =
                    'https://nominatim.openstreetmap.org/search' +
                    '?format=jsonv2' +
                    '&limit=1' +
                    '&accept-language=fr' +
                    '&addressdetails=0' +
                    `&q=${encodeURIComponent(query)}`;

                const r = await fetch(url, {
                    headers: {
                        'Accept': 'application/json',
                        'User-Agent': 'DetourZero-localtest/1.0 (contact: test@example.com)'
                    }
                });

                if (!r.ok) throw new Error('GÃ©ocodage indisponible');

                const d = await r.json();
                if (!d.length)
                    throw new Error('Adresse introuvable : ' + s);

                out.push({
                    id: it.id,
                    index: out.length,
                    name: it.name || '',
                    address: it.address,
                    lat: +d[0].lat,
                    lon: +d[0].lon,
                    display: d[0].display_name
                });

                // pause anti rate-limit
                await new Promise(res => setTimeout(res, 220));
            }

            out.forEach((p, i) => p.index = i);
            return out;
        }

        // ------- Bouton GÃ©ocoder -------
        el.geocode.addEventListener('click', async () => {
            try {
                if (raw.length < 2) {
                    alert('Ajoute le dÃ©pÃ´t + 1 adresse.');
                    return;
                }

                startLoading(el.geocode, 'â³ GÃ©ocodage...');

                clearMap();
                points = await geocodeAll(raw);

                drawMarkers();
                renderList('raw');

                el.optimize.disabled = points.length > 1 ? false : true;
                el.draw.disabled = true;

                el.sumDist.textContent = 'Distance totale : â€“';
                el.sumTime.textContent = 'DurÃ©e totale (â‰ˆ) : â€“';
            } catch (e) {
                alert(e.message || e);
            } finally {
                stopLoading(el.geocode, '1) GÃ©ocoder');
            }
        });

        // ------- OSRM table -------
        async function osrmTable(pts) {
            const coords = pts.map(p => `${p.lon},${p.lat}`).join(';');
            const r = await fetch(
                `https://router.project-osrm.org/table/v1/driving/${coords}?annotations=duration,distance`
            );
            if (!r.ok) throw new Error('OSRM table indisponible');
            return r.json();
        }

        // ------- Algo optimisation (NN + 2-opt) -------
        function nearestNeighbor(d) {
            const n = d.length;
            const used = Array(n).fill(false);
            const path = [0];
            used[0] = true;

            for (let k = 1; k < n; k++) {
                let last = path[path.length - 1];
                let best = -1;
                let c = 1e18;

                for (let j = 1; j < n; j++) {
                    if (!used[j] && d[last][j] < c) {
                        c = d[last][j];
                        best = j;
                    }
                }
                path.push(best);
                used[best] = true;
            }
            return path;
        }

        function twoOpt(path, d) {
            const n = path.length;
            const cost = (a, b) => d[a][b];
            let improved = true;

            while (improved) {
                improved = false;
                for (let i = 1; i < n - 2; i++) {
                    for (let k = i + 1; k < n - 1; k++) {
                        const a = path[i - 1],
                            b = path[i],
                            c = path[k],
                            e = path[k + 1];

                        const delta =
                            (cost(a, c) + cost(b, e)) -
                            (cost(a, b) + cost(c, e));

                        if (delta < -1e-6) {
                            const rev = path.slice(i, k + 1).reverse();
                            path.splice(i, k - i + 1, ...rev);
                            improved = true;
                        }
                    }
                }
            }
            return path;
        }

        // ------- Bouton Optimiser -------
        el.optimize.addEventListener('click', async () => {
            try {
                if (points.length < 2) return;

                startLoading(el.optimize, 'â³ Optimisation...');

                const matrix = await osrmTable(points);
                // DurÃ©es en minutes
                const dur = matrix.durations.map(row =>
                    row.map(x => (x ?? 1e9) / 60)
                );

                // 1. nearest neighbor
                let path = nearestNeighbor(dur);
                // 2. 2-opt
                path = twoOpt(path, dur);
                // 3. retour au dÃ©pÃ´t
                path.push(0);

                // Stats distance / durÃ©e
                let travelMins = 0;
                let travelKm = 0;
                for (let i = 0; i < path.length - 1; i++) {
                    travelMins += dur[path[i]][path[i + 1]];
                    if (matrix.distances) {
                        travelKm +=
                            (matrix.distances[path[i]][path[i + 1]] || 0) / 1000;
                    }
                }

                el.sumTime.textContent =
                    'DurÃ©e totale (â‰ˆ) : ' + minsToStr(travelMins);
                el.sumDist.textContent =
                    'Distance totale : ' +
                    (travelKm
                        ? travelKm.toFixed(1) + ' km'
                        : 'â‰ˆ â€“');

                // SÃ©quence ordonnÃ©e finale
                ordered = path.map(i => points[i]);
                renderList('ordered');

                el.draw.disabled = false;
            } catch (e) {
                alert(e.message || e);
            } finally {
                stopLoading(el.optimize, '2) Optimiser');
            }
        });

        // ------- Bouton Tracer lâ€™itinÃ©raire -------
        el.draw.addEventListener('click', async () => {
            try {
                if (!ordered.length) return;

                startLoading(el.draw, 'â³ TraÃ§age...');

                routeLayer.clearLayers();

                const coords = ordered
                    .map(p => `${p.lon},${p.lat}`)
                    .join(';');

                const r = await fetch(
                    `https://router.project-osrm.org/route/v1/driving/${coords}?overview=full&geometries=geojson`
                );
                if (!r.ok) throw new Error('OSRM route indisponible');

                const data = await r.json();
                routeGeo = data.routes[0].geometry;
                routeLayer.addData(routeGeo);

                const gj = L.geoJSON(routeGeo);
                map.fitBounds(gj.getBounds(), { padding: [40, 40] });
            } catch (e) {
                alert(e.message || e);
            } finally {
                stopLoading(el.draw, '3) Tracer lâ€™itinÃ©raire');
            }
        });

        // ------- Init page -------
        loadState();
        renderList();
    </script>
</body>

</html>