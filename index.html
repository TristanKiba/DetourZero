<!doctype html>
<html lang="fr">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>DetourZero â€” Optimiseur de tournÃ©e (client-side)</title>

    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
</head>

<body>
    <header>
        <div class="logo" aria-hidden="true"></div>
        <h1>DetourZero â€” Optimiseur de tournÃ©e</h1>
        <span class="tag">100% client-side Â· OSRM Â· Nominatim</span>
    </header>

    <main class="wrap">
        <!-- Panneau gauche -->
        <section class="panel">
            <div class="row">
                <label>Ajouter une adresse (dÃ©part = premiÃ¨re ligne)</label>

                <!-- Formulaire ajout (Nom + Adresse) -->
                <div class="grid-form">
                    <input id="client" placeholder="Nom client" />
                    <input id="addr" placeholder="Adresse (ex: 5 Rue de l'Ã‰glise, 62570 Helfaut)" />
                    <div class="hstack form-actions">
                        <button class="btn primary" id="add">+ Ajouter</button>
                        <button class="btn ghost" id="clear">Vider la liste</button>
                    </div>
                </div>
            </div>

            <div class="row hstack">
                <button class="btn" id="geocode">1) GÃ©ocoder</button>
                <button class="btn primary" id="optimize" disabled>2) Optimiser</button>
                <button class="btn accent" id="draw" disabled>3) Tracer lâ€™itinÃ©raire</button>
            </div>

            <div class="row">
                <label>Ã‰tapes</label>
                <div class="list" id="list">
                    <div class="empty mini">Aucun arrÃªt â€” ajoute une adresse.</div>
                </div>

                <div class="summary" style="margin-top:10px">
                    <div class="sum" id="sumDist">Distance totale : â€“</div>
                    <div class="sum" id="sumTime">DurÃ©e totale (â‰ˆ) : â€“</div>
                </div>
            </div>
        </section>

        <!-- Panneau droit -->
        <section class="panel map-panel">
            <div id="map">
                <div class="map-placeholder">
                    <div class="map-title">AperÃ§u carte</div>
                    <div class="map-hint">(Le tracÃ© sâ€™affichera aprÃ¨s Â« Tracer lâ€™itinÃ©raire Â»)</div>
                </div>
            </div>
        </section>
    </main>

    <!-- ===== JS intÃ©grÃ© ===== -->
    <script>
        // ------- SÃ©lecteurs -------
        const $ = s => document.querySelector(s);
        const el = {
            client: $('#client'), addr: $('#addr'),
            add: $('#add'), clear: $('#clear'),
            geocode: $('#geocode'), optimize: $('#optimize'), draw: $('#draw'),
            list: $('#list'), sumDist: $('#sumDist'), sumTime: $('#sumTime')
        };

        // ------- Persistance -------
        const LS_KEY = 'detourzero_clients_nowo_v1';
        // raw: {id, name, address}
        let raw = [];
        const genId = () => Math.random().toString(36).slice(2) + Date.now().toString(36);

        function saveState() { localStorage.setItem(LS_KEY, JSON.stringify(raw)); }
        function loadState() {
            try {
                raw = JSON.parse(localStorage.getItem(LS_KEY) || '[]') || [];
                raw.forEach(r => { if (!r.id) r.id = genId(); });
            } catch { raw = []; }
        }

        // Points gÃ©ocodÃ©s : {id,index,name,address,lat,lon,display,eta}
        let points = [];
        let ordered = [];
        let routeGeo = null;

        // ------- Temps (pour formatage) -------
        const minsToStr = m => { m = Math.round(m); const h = Math.floor(m / 60), mm = m % 60; return h ? `${h} h ${String(mm).padStart(2, '0')} min` : `${mm} min`; };

        // ------- Carte Leaflet -------
        const map = L.map('map').setView([48.8566, 2.3522], 6);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '&copy; OpenStreetMap' }).addTo(map);
        const markersLayer = L.layerGroup().addTo(map);
        const routeLayer = L.geoJSON(null, { style: { weight: 4 } }).addTo(map);

        function fitTo(arr) {
            if (!arr.length) return;
            map.fitBounds(L.latLngBounds(arr.map(p => [p.lat, p.lon])), { padding: [28, 28] });
        }
        function clearMap() {
            markersLayer.clearLayers();
            routeLayer.clearLayers();
            routeGeo = null;
        }
        function drawMarkers() {
            markersLayer.clearLayers();
            points.forEach((p, i) => {
                L.marker([p.lat, p.lon]).addTo(markersLayer)
                    .bindPopup(`<b>${i === 0 ? 'DÃ©pÃ´t ' : ''}#${i}</b><br>${p.name ? ('<i>' + p.name + '</i><br>') : ''}${p.display || p.address}`);
            });
            if (points.length) fitTo(points);
        }

        // ------- Liste -------
        function renderList(view = 'raw') {
            const src = (view === 'ordered' && ordered.length) ? ordered : (points.length ? points : raw.map((r, i) => ({ id: r.id, index: i, name: r.name, address: r.address })));
            if (!src.length) { el.list.innerHTML = '<div class="empty mini">Aucun arrÃªt â€” ajoute une adresse.</div>'; return; }
            el.list.innerHTML = src.map((p, i) => `
        <div class="card">
          <div class="idx">${i}</div>
          <div class="txt">
            <div><strong>${p.name || '(Sans nom)'}</strong></div>
            <div class="mini">${p.address}</div>
            ${p.lat && p.lon ? `<div class="mini">(${p.lat.toFixed(5)}, ${p.lon.toFixed(5)})</div>` : ''}
          </div>
          <button class="iconbtn" title="Supprimer" onclick="delStop('${p.id}')">ðŸ—‘</button>
        </div>
      `).join('');
        }
        window.delStop = function (id) {
            const i = raw.findIndex(r => r.id === id);
            if (i > -1) raw.splice(i, 1);
            saveState();
            points = points.filter(p => p.id !== id);
            ordered = ordered.filter(p => p.id !== id);
            clearMap(); drawMarkers(); renderList();
            el.optimize.disabled = points.length > 1 ? false : true;
            el.draw.disabled = true;
            el.sumDist.textContent = 'Distance totale : â€“';
            el.sumTime.textContent = 'DurÃ©e totale (â‰ˆ) : â€“';
        };

        // ------- Ajout & clear -------
        el.add.addEventListener('click', () => {
            const name = el.client.value.trim();
            const addr = el.addr.value.trim();
            if (!addr) { alert('Adresse obligatoire.'); return; }
            if (raw.length >= 150) { alert('Limite : 150 adresses.'); return; }
            raw.push({ id: genId(), name, address: addr });
            saveState();
            el.client.value = ''; el.addr.value = '';
            renderList();
        });
        el.addr.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); el.add.click(); } });

        el.clear.addEventListener('click', () => {
            if (!raw.length) { alert('La liste est dÃ©jÃ  vide.'); return; }
            if (!confirm('Vider TOUTE la liste de clients ?')) return;
            raw = []; saveState();
            points = []; ordered = []; clearMap(); renderList();
            el.optimize.disabled = true; el.draw.disabled = true;
            el.sumDist.textContent = 'Distance totale : â€“';
            el.sumTime.textContent = 'DurÃ©e totale (â‰ˆ) : â€“';
        });

        // ------- GÃ©ocodage (Nominatim) -------
        async function geocodeAll(items) {
            const out = [];
            for (const it of items) {
                const s = (it.address || '').trim(); if (!s) continue;
                const m = s.match(/(-?\d+\.?\d*)[,; ]+(-?\d+\.?\d*)/);
                if (m && Math.abs(+m[1]) <= 90 && Math.abs(+m[2]) <= 180) {
                    out.push({ id: it.id, index: out.length, name: it.name || '', address: it.address, lat: +m[1], lon: +m[2], display: it.address });
                    continue;
                }
                const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&q=${encodeURIComponent(s)}&limit=1&accept-language=fr`;
                const r = await fetch(url, { headers: { 'Accept': 'application/json' } });
                if (!r.ok) throw new Error('GÃ©ocodage indisponible');
                const d = await r.json(); if (!d.length) throw new Error('Adresse introuvable : ' + s);
                out.push({ id: it.id, index: out.length, name: it.name || '', address: it.address, lat: +d[0].lat, lon: +d[0].lon, display: d[0].display_name });
                await new Promise(res => setTimeout(res, 220)); // rate-limit
            }
            out.forEach((p, i) => p.index = i);
            return out;
        }

        el.geocode.addEventListener('click', async () => {
            try {
                if (raw.length < 2) { alert('Ajoute le dÃ©pÃ´t + 1 adresse.'); return; }
                clearMap();
                points = await geocodeAll(raw);
                drawMarkers(); renderList('raw');
                el.optimize.disabled = points.length > 1 ? false : true;
                el.draw.disabled = true;
                el.sumDist.textContent = 'Distance totale : â€“';
                el.sumTime.textContent = 'DurÃ©e totale (â‰ˆ) : â€“';
            } catch (e) { alert(e.message || e); }
        });

        // ------- OSRM (table) -------
        async function osrmTable(pts) {
            const coords = pts.map(p => `${p.lon},${p.lat}`).join(';');
            const r = await fetch(`https://router.project-osrm.org/table/v1/driving/${coords}?annotations=duration,distance`);
            if (!r.ok) throw new Error('OSRM table indisponible');
            return r.json();
        }

        // ------- Optimisation (NN + 2-opt) -------
        function nearestNeighbor(d) {
            const n = d.length, used = Array(n).fill(false), path = [0]; used[0] = true;
            for (let k = 1; k < n; k++) {
                let last = path[path.length - 1], best = -1, c = 1e18;
                for (let j = 1; j < n; j++) if (!used[j] && d[last][j] < c) { c = d[last][j]; best = j; }
                path.push(best); used[best] = true;
            }
            return path;
        }
        function twoOpt(path, d) {
            const n = path.length, cost = (a, b) => d[a][b]; let improved = true;
            while (improved) {
                improved = false;
                for (let i = 1; i < n - 2; i++) for (let k = i + 1; k < n - 1; k++) {
                    const a = path[i - 1], b = path[i], c = path[k], e = path[k + 1];
                    const delta = (cost(a, c) + cost(b, e)) - (cost(a, b) + cost(c, e));
                    if (delta < -1e-6) { const rev = path.slice(i, k + 1).reverse(); path.splice(i, k - i + 1, ...rev); improved = true; }
                }
            }
            return path;
        }

        el.optimize.addEventListener('click', async () => {
            try {
                if (points.length < 2) return;
                const matrix = await osrmTable(points);
                const dur = matrix.durations.map(row => row.map(x => (x ?? 1e9) / 60)); // minutes

                // ordre : dÃ©pÃ´t (0) puis NN + 2-opt, retour dÃ©pÃ´t
                let path = nearestNeighbor(dur);
                path = twoOpt(path, dur);
                path.push(0);

                // stats
                let travelMins = 0, travelKm = 0;
                for (let i = 0; i < path.length - 1; i++) {
                    travelMins += dur[path[i]][path[i + 1]];
                    if (matrix.distances) travelKm += (matrix.distances[path[i]][path[i + 1]] || 0) / 1000;
                }
                el.sumTime.textContent = 'DurÃ©e totale (â‰ˆ) : ' + minsToStr(travelMins);
                el.sumDist.textContent = 'Distance totale : ' + (travelKm ? travelKm.toFixed(1) + ' km' : 'â‰ˆ â€“');

                ordered = path.map(i => points[i]);
                renderList('ordered');
                el.draw.disabled = false;
            } catch (e) { alert(e.message || e); }
        });

        // ------- Tracer lâ€™itinÃ©raire complet (OSRM route) -------
        el.draw.addEventListener('click', async () => {
            try {
                if (!ordered.length) return;
                routeLayer.clearLayers();
                const coords = ordered.map(p => `${p.lon},${p.lat}`).join(';');
                const r = await fetch(`https://router.project-osrm.org/route/v1/driving/${coords}?overview=full&geometries=geojson`);
                if (!r.ok) throw new Error('OSRM route indisponible');
                const data = await r.json();
                routeGeo = data.routes[0].geometry;
                routeLayer.addData(routeGeo);
                const gj = L.geoJSON(routeGeo);
                map.fitBounds(gj.getBounds(), { padding: [40, 40] });
            } catch (e) { alert(e.message || e); }
        });

        // ------- Init -------
        loadState();
        renderList();
    </script>
</body>

</html>